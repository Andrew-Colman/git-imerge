#! /bin/sh

# This should be executed in a clean working copy of the test repo.

set -e
set -x

BASE="$(dirname "$(cd $(dirname "$0") && pwd)")"
. "$BASE/t/test-lib.sh"

GIT_IMERGE="git-imerge"
TMP="$BASE/t/tmp/flip-flop"
DESCRIPTION="git-imerge test repository with a commit and its revert"

# Set up a test repo with two branches, `a` and `b`, where `b` has a
# commit that conflicts with one from `a` that is immediately
# reverted. This should make it look like the whole block can be
# merged, only to fail when outlining, forcing backtracking that
# ultimately also fails.
init_test_repo "$TMP" "$DESCRIPTION"
cd "$TMP"

modify a.txt 0
commit -m 'm⇒0'

git checkout -b a --
for i in 1 2 3
do
    modify a.txt $i
    commit -m "a⇒$i on branch a"
done

git checkout -b b master --
modify b.txt 1
commit -m "b⇒1"
modify a.txt X
commit -m "a⇒X on branch b"
modify a.txt 0
commit -m "revert a⇒0 on branch b"
modify b.txt 2
commit -m "b⇒2"

git checkout a
"$GIT_IMERGE" merge b 2>&1 | tee imerge-1.out

"$GIT_IMERGE" diagram --commits --frontier

if ! grep -q 'There was a conflict merging commit 1-2' imerge-1.out
then
    echo "conflict along outline not detected"
    exit 1
fi

# Fix the first conflict:
echo 1 >a.txt
git add a.txt
"$GIT_IMERGE" continue --no-edit 2>&1 | tee imerge-2.out

"$GIT_IMERGE" diagram --commits --frontier

if ! grep -q 'There was a conflict merging commit 1-3' imerge-2.out
then
    echo "conflict along outline not detected"
    exit 1
fi

# Fix the second conflict:
echo 1 >a.txt
git add a.txt
"$GIT_IMERGE" continue --no-edit 2>&1 | tee imerge-3.out
if ! grep -q 'Merge is complete' imerge-3.out
then
    echo "merge failed"
    exit 1
fi

"$GIT_IMERGE" diagram --commits --frontier

GIT_EDITOR=cat "$GIT_IMERGE" finish
